{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"TypeSystem TypeSystem is a comprehensive data validation library that gives you: Data validation. Object serialization & deserialization. Form rendering. Marshaling validators to/from JSON schema. Tokenizing JSON or YAML to provide positional error messages. 100% type annotated codebase. 100% test coverage. Zero hard dependencies. Requirements Python 3.6+ Installation $ pip3 install typesystem If you'd like you use the form rendering you'll also want to install jinja2 . $ pip3 install jinja2 Quickstart import typesystem class Artist ( typesystem . Schema ): name = typesystem . String ( max_length = 100 ) class Album ( typesystem . Schema ): title = typesystem . String ( max_length = 100 ) release_date = typesystem . Date () artist = typesystem . Reference ( Artist ) album = Album . validate ({ \"title\" : \"Double Negative\" , \"release_date\" : \"2018-09-14\" , \"artist\" : { \"name\" : \"Low\" } }) print ( album ) # Album(title='Double Negative', release_date=datetime.date(2018, 9, 14), artist=Artist(name='Low')) print ( album . release_date ) # datetime.date(2018, 9, 14) print ( album [ 'release_date' ]) # '2018-09-14' print ( dict ( album )) # {'title': 'Double Negative', 'release_date': '2018-09-14', 'artist': {'name': 'Low'}} Alternatives There are plenty of other great validation libraries for Python out there, including Marshmallow , Schematics , Voluptuous , and many others. TypeSystem exists because I want a data validation library that offers first-class support for: Rendering validation classes into HTML forms. Marshaling to/from JSON Schema. Obtaining positional errors within JSON or YAML documents. \u2014 \u2b50\ufe0f \u2014 TypeSystem is BSD licensed code. Designed & built in Brighton, England.","title":"Introduction"},{"location":"#typesystem","text":"TypeSystem is a comprehensive data validation library that gives you: Data validation. Object serialization & deserialization. Form rendering. Marshaling validators to/from JSON schema. Tokenizing JSON or YAML to provide positional error messages. 100% type annotated codebase. 100% test coverage. Zero hard dependencies.","title":"TypeSystem"},{"location":"#requirements","text":"Python 3.6+","title":"Requirements"},{"location":"#installation","text":"$ pip3 install typesystem If you'd like you use the form rendering you'll also want to install jinja2 . $ pip3 install jinja2","title":"Installation"},{"location":"#quickstart","text":"import typesystem class Artist ( typesystem . Schema ): name = typesystem . String ( max_length = 100 ) class Album ( typesystem . Schema ): title = typesystem . String ( max_length = 100 ) release_date = typesystem . Date () artist = typesystem . Reference ( Artist ) album = Album . validate ({ \"title\" : \"Double Negative\" , \"release_date\" : \"2018-09-14\" , \"artist\" : { \"name\" : \"Low\" } }) print ( album ) # Album(title='Double Negative', release_date=datetime.date(2018, 9, 14), artist=Artist(name='Low')) print ( album . release_date ) # datetime.date(2018, 9, 14) print ( album [ 'release_date' ]) # '2018-09-14' print ( dict ( album )) # {'title': 'Double Negative', 'release_date': '2018-09-14', 'artist': {'name': 'Low'}}","title":"Quickstart"},{"location":"#alternatives","text":"There are plenty of other great validation libraries for Python out there, including Marshmallow , Schematics , Voluptuous , and many others. TypeSystem exists because I want a data validation library that offers first-class support for: Rendering validation classes into HTML forms. Marshaling to/from JSON Schema. Obtaining positional errors within JSON or YAML documents. \u2014 \u2b50\ufe0f \u2014 TypeSystem is BSD licensed code. Designed & built in Brighton, England.","title":"Alternatives"},{"location":"examples/","text":"The following are examples of integrating typesystem against a Web framework. API validation & serialization Using typesystem for validation and serialization of a simple Web API. requirements.txt starlette typesystem uvicorn app.py from starlette.applications import Starlette from starlette.responses import JSONResponse from starlette.routing import Route import typesystem import uvicorn users = [] class User ( typesystem . Schema ): username = typesystem . String ( max_length = 100 ) is_admin = typesystem . Boolean ( default = False ) async def list_users ( request ): return JSONResponse ({ \"users\" : [ dict ( user ) for user in users ]}) async def add_user ( request ): data = await request . json () user , errors = User . validate_or_error ( data ) if errors : return JSONResponse ( dict ( errors ), status_code = 400 ) users . append ( user ) return JSONResponse ( dict ( user )) app = Starlette ( debug = True , routes = [ Route ( '/' , list_users , methods = [ \"GET\" ]), Route ( '/' , add_user , methods = [ \"POST\" ]), ]) if __name__ == \"__main__\" : uvicorn . run ( app ) Form rendering Using typesystem for a simple Web submission page. requirements.txt aiofiles # Static files support boostrap4 # Form templates & static files jinja2 # Form rendering python-multipart # Form parsing starlette typesystem uvicorn app.py from starlette.applications import Starlette from starlette.responses import RedirectResponse from starlette.routing import Route , Mount from starlette.staticfiles import StaticFiles from starlette.templating import Jinja2Templates import typesystem import uvicorn forms = typesystem . Jinja2Forms ( package = \"bootstrap4\" ) templates = Jinja2Templates ( directory = \"templates\" ) statics = StaticFiles ( directory = \"statics\" , packages = [ \"bootstrap4\" ]) bookings = [] class BookingSchema ( typesystem . Schema ): start_date = typesystem . Date ( title = \"Start date\" ) end_date = typesystem . Date ( title = \"End date\" ) room = typesystem . Choice ( title = \"Room type\" , choices = [ ( \"double\" , \"Double room\" ), ( \"twin\" , \"Twin room\" ), ( \"single\" , \"Single room\" ), ], ) include_breakfast = typesystem . Boolean ( title = \"Include breakfast\" , default = False ) def __str__ ( self ): breakfast = ( \"(with breakfast)\" if self . include_breakfast else \"(without breakfast)\" ) return f \"Booking for {self.room} from {self.start_date} to {self.end_date}\" async def homepage ( request ): form = forms . Form ( BookingSchema ) context = { \"request\" : request , \"form\" : form , \"bookings\" : bookings } return templates . TemplateResponse ( \"index.html\" , context ) async def make_booking ( request ): data = await request . form () booking , errors = BookingSchema . validate_or_error ( data ) if errors : form = forms . Form ( BookingSchema , values = data , errors = errors ) context = { \"request\" : request , \"form\" : form , \"bookings\" : bookings } return templates . TemplateResponse ( \"index.html\" , context ) bookings . append ( booking ) return RedirectResponse ( request . url_for ( \"homepage\" )) app = Starlette ( debug = True , routes = [ Route ( \"/\" , homepage , methods = [ \"GET\" ]), Route ( \"/\" , make_booking , methods = [ \"POST\" ]), Mount ( \"/statics\" , statics , name = \"static\" ), ], ) if __name__ == \"__main__\" : uvicorn . run ( app ) templates/index.html <!doctype html> < html lang = \"en\" > < head > < meta charset = \"utf-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1, shrink-to-fit=no\" > < meta name = \"description\" content = \"\" > < meta name = \"author\" content = \"\" > < title > TypeSystem </ title > < link href = \"{{ url_for('static', path='/css/bootstrap.min.css') }}\" rel = \"stylesheet\" > < link href = \"{{ url_for('static', path='/css/base.css') }}\" rel = \"stylesheet\" > </ head > < body > < main role = \"main\" class = \"container\" > < div class = \"booking-list\" > < h4 > Current bookings </ h4 > < div > {% if bookings %} < ul > {% for booking in bookings %} < li > {{ booking }} </ li > {% endfor %} </ ul > {% else %} < em > None </ em > {% endif %} </ div > </ div > < hr /> < div class = \"booking-form\" > < h4 > New booking </ h4 > < form method = \"POST\" > {{ form }} < div class = \"submit-controls\" > < button type = \"submit\" class = \"btn btn-primary\" > Submit </ button > </ div > </ form > </ div > </ main > < script src = \"https://code.jquery.com/jquery-3.2.1.slim.min.js\" integrity = \"sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN\" crossorigin = \"anonymous\" ></ script > < script src = \"https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js\" integrity = \"sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q\" crossorigin = \"anonymous\" ></ script > < script src = \"{{ url_for('static', path='js/bootstrap.min.js') }}\" ></ script > </ body > </ html > statics/css/base.css . container { padding-top : 20 px ; max-width : 500 px ; } . booking-list { padding : 20 px 0 30 px ; } . booking-list li { padding : 10 px 0 ; } . booking-form form { padding : 10 px 0 ; } . submit-controls { padding : 15 px 0 ; }","title":"Examples"},{"location":"examples/#api-validation-serialization","text":"Using typesystem for validation and serialization of a simple Web API. requirements.txt starlette typesystem uvicorn app.py from starlette.applications import Starlette from starlette.responses import JSONResponse from starlette.routing import Route import typesystem import uvicorn users = [] class User ( typesystem . Schema ): username = typesystem . String ( max_length = 100 ) is_admin = typesystem . Boolean ( default = False ) async def list_users ( request ): return JSONResponse ({ \"users\" : [ dict ( user ) for user in users ]}) async def add_user ( request ): data = await request . json () user , errors = User . validate_or_error ( data ) if errors : return JSONResponse ( dict ( errors ), status_code = 400 ) users . append ( user ) return JSONResponse ( dict ( user )) app = Starlette ( debug = True , routes = [ Route ( '/' , list_users , methods = [ \"GET\" ]), Route ( '/' , add_user , methods = [ \"POST\" ]), ]) if __name__ == \"__main__\" : uvicorn . run ( app )","title":"API validation &amp; serialization"},{"location":"examples/#form-rendering","text":"Using typesystem for a simple Web submission page. requirements.txt aiofiles # Static files support boostrap4 # Form templates & static files jinja2 # Form rendering python-multipart # Form parsing starlette typesystem uvicorn app.py from starlette.applications import Starlette from starlette.responses import RedirectResponse from starlette.routing import Route , Mount from starlette.staticfiles import StaticFiles from starlette.templating import Jinja2Templates import typesystem import uvicorn forms = typesystem . Jinja2Forms ( package = \"bootstrap4\" ) templates = Jinja2Templates ( directory = \"templates\" ) statics = StaticFiles ( directory = \"statics\" , packages = [ \"bootstrap4\" ]) bookings = [] class BookingSchema ( typesystem . Schema ): start_date = typesystem . Date ( title = \"Start date\" ) end_date = typesystem . Date ( title = \"End date\" ) room = typesystem . Choice ( title = \"Room type\" , choices = [ ( \"double\" , \"Double room\" ), ( \"twin\" , \"Twin room\" ), ( \"single\" , \"Single room\" ), ], ) include_breakfast = typesystem . Boolean ( title = \"Include breakfast\" , default = False ) def __str__ ( self ): breakfast = ( \"(with breakfast)\" if self . include_breakfast else \"(without breakfast)\" ) return f \"Booking for {self.room} from {self.start_date} to {self.end_date}\" async def homepage ( request ): form = forms . Form ( BookingSchema ) context = { \"request\" : request , \"form\" : form , \"bookings\" : bookings } return templates . TemplateResponse ( \"index.html\" , context ) async def make_booking ( request ): data = await request . form () booking , errors = BookingSchema . validate_or_error ( data ) if errors : form = forms . Form ( BookingSchema , values = data , errors = errors ) context = { \"request\" : request , \"form\" : form , \"bookings\" : bookings } return templates . TemplateResponse ( \"index.html\" , context ) bookings . append ( booking ) return RedirectResponse ( request . url_for ( \"homepage\" )) app = Starlette ( debug = True , routes = [ Route ( \"/\" , homepage , methods = [ \"GET\" ]), Route ( \"/\" , make_booking , methods = [ \"POST\" ]), Mount ( \"/statics\" , statics , name = \"static\" ), ], ) if __name__ == \"__main__\" : uvicorn . run ( app ) templates/index.html <!doctype html> < html lang = \"en\" > < head > < meta charset = \"utf-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1, shrink-to-fit=no\" > < meta name = \"description\" content = \"\" > < meta name = \"author\" content = \"\" > < title > TypeSystem </ title > < link href = \"{{ url_for('static', path='/css/bootstrap.min.css') }}\" rel = \"stylesheet\" > < link href = \"{{ url_for('static', path='/css/base.css') }}\" rel = \"stylesheet\" > </ head > < body > < main role = \"main\" class = \"container\" > < div class = \"booking-list\" > < h4 > Current bookings </ h4 > < div > {% if bookings %} < ul > {% for booking in bookings %} < li > {{ booking }} </ li > {% endfor %} </ ul > {% else %} < em > None </ em > {% endif %} </ div > </ div > < hr /> < div class = \"booking-form\" > < h4 > New booking </ h4 > < form method = \"POST\" > {{ form }} < div class = \"submit-controls\" > < button type = \"submit\" class = \"btn btn-primary\" > Submit </ button > </ div > </ form > </ div > </ main > < script src = \"https://code.jquery.com/jquery-3.2.1.slim.min.js\" integrity = \"sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN\" crossorigin = \"anonymous\" ></ script > < script src = \"https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js\" integrity = \"sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q\" crossorigin = \"anonymous\" ></ script > < script src = \"{{ url_for('static', path='js/bootstrap.min.js') }}\" ></ script > </ body > </ html > statics/css/base.css . container { padding-top : 20 px ; max-width : 500 px ; } . booking-list { padding : 20 px 0 30 px ; } . booking-list li { padding : 10 px 0 ; } . booking-form form { padding : 10 px 0 ; } . submit-controls { padding : 15 px 0 ; }","title":"Form rendering"},{"location":"fields/","text":"Fields are usually declared as attributes on schema classes: class Organisation ( typesystem . Schema ): name = typesystem . String ( title = \"Name\" , max_length = 100 ) date_created = typesystem . Date ( title = \"Date created\" , default = datetime . date . today ) owner = typesystem . Reference ( to = User , allow_null = True ) Fields are always required in inputs, unless a default value is set. Setting allow_null to True will set the default to None . (Unless default is already set.) Setting allow_blank to True will set the default to \"\" . (Unless default or allow_null is already set.) All fields support the following arguments. Arguments : title - A string to use when labelling the input. Default: None description - A string describing the input. Default: None default - A value to be used if no input is provided for this field. May be a callable, such as datetime.datetime.now . Default: NO_DEFAULT allow_null - A boolean determining if None values are valid. Default: False Using fields directly You can use fields to validate data directly, rather than using them on a schema class. This is useful if you have a general datastructure that requires validation. For instance, we could validate a dictionary of integers, like so: validator = typesystem . Object ( properties = typesystem . Integer ()) value = validator . validate ( data ) # May raise `ValidationError` Or returning a two-tuple of (value, ValidationError) : validator = typesystem . Object ( properties = typesystem . Integer ()) value , error = validator . validate_or_error ( data ) if error : ... else : ... Textual data types String Validates single-line text inputs. For example: username = typesystem.String(max_length=100) Arguments : allow_blank - A boolean indicating if the empty string should validate. Default: False trim_whitespace - A boolean indicating if leading/trailing whitespace should be removed on validation. Default: True max_length - A maximum number of characters that valid input stings may contain. Default: None min_length - A minimum number of characters that valid input stings may contain. Default: None pattern - A regular expression that must match. This can be either a string or a compiled regular expression. E.g. pattern=\"^[A-Za-z]+$\" Default: None format - A string used to indicate a semantic type, such as \"email\" , \"url\" , or \"color\" . Default: None Text Validates multi-line strings. Takes the same arguments as String . Represented in HTML forms as a <textarea> . Boolean data types Boolean Represented in HTML forms as a <checkbox> . For example: is_admin = typesystem . Boolean ( default = False ) Because all fields are required unless a default is given, you'll typically want to use default=False . This is particularly true if you want to render boolean fields as HTML checkboxes, since they do not submit any input if unchecked. Numeric data types Number The base class for Integer , Float , and Decimal . You won't typically want to use this class directly, since the subclasses provide more precise behaviour. Arguments : minimum - A number representing the minimum allowed value. Inputs must be greater than or equal to this to validate. Default: None maximum - A number representing the maximum allowed value. Inputs must be less than or equal to this to validate. Default: None exclusive_minimum - A number representing an exclusive minimum. Inputs must be greater than this to validate. Default: None exclusive_maximum - A number representing an exclusive maximum. Inputs must be less than this to validate. Default: None precision - A string representing the decimal precision to truncate input with. E.g. precision=\"0.001\" . Default: None multiple_of - A number giving a value that inputs must be a strict multiple of in order to validate. E.g. multiple_of=2 will only validate even integers. Default: None Integer Takes the same arguments as Number . Returns instances of int . Float Takes the same arguments as Number . Returns instances of float . Decimal Takes the same arguments as Number . Returns instances of decimal.Decimal . Enumeration data types Choice Provides a fixed set of options to select from. Represented in HTML forms as a <select> . Arguments : choices - A list of two-tuples of (choice, description) . Default: None Date and time data types DateTime Validates ISO 8601 formatted datetimes. For example \"2020-02-29T12:34:56Z\" . Returns datetime.datetime instances. Date Validates ISO 8601 formatted dates. For example \"2020-02-29\" . Returns datetime.date instances. Time Validates ISO 8601 formatted times. For example \"12:34:56\" . Returns datetime.time instances. Composite data types Array Used to validate a list of data. For example: # Validates data like `[8, 7, 0, 8, 4, 5]` ratings = typesystem . Array ( items = typesystem . Integer ( min_value = 0 , max_value = 10 )) Arguments : items - Either a Field , used to validate each item in the list. Or a list of Field instances, used to validate each item in the list, positionally. Default: None additional_items - Only valid if items is a list. Either True or False , or a Field . Used to validate each additional item in the list. Default: False min_items - An integer, indicating the minimum number of items that must be present in the list. Default: None max_items - An integer, indicating the maximum number of items that may be present in the list. Default: None exact_items - An integer, indicating the exact number of items that must be present in the list. Default: None unique_items - A boolean. Used to determine if duplicate items are allowed in the list. Default: False Object Used to validate a dictionary of data. # Validates data like `{\"address\": \"12 Steeple close\", \"delivery note\": \"Leave by porch\"}` extra_metadata = typesystem . Object ( properties = typesystem . String ( max_length = 100 )) Schema classes implement their validation behaviour by generating an Object field, and automatically determining the properties and required attributes. You'll typically want to use typesystem.Reference(to=SomeSchema) rather than using the Object field directly, but it can be useful if you have a more complex data structure that you need to validate. Arguments : properties - Either a Field , used to validate each value in the object. Or a dictionary of Field instances, used to validate each item in the list, by field name. Default: None pattern_properties - A dictionary mapping regex-style strings to field instances. Used to validate any items not in properties that have a key matching the regex. Default: None additional_properties - Either a boolean, used to indicate if additional properties are allowed, or a Field used to validate any items not in properties or pattern_properties . If None then additional properties are allowed, but are not included in the validated value. Default: None min_properties - An integer representing the minimum number of properties that must be included. max_properties - An integer representing the maximum number of properties that may be included. required - A list of strings indicating any fields that are strictly required in the input. Reference Used to reference a nested schema. For example: owner = typesystem . Reference ( to = User , allow_null = True ) Arguments : to - A schema class or field instance. Required","title":"Fields"},{"location":"fields/#using-fields-directly","text":"You can use fields to validate data directly, rather than using them on a schema class. This is useful if you have a general datastructure that requires validation. For instance, we could validate a dictionary of integers, like so: validator = typesystem . Object ( properties = typesystem . Integer ()) value = validator . validate ( data ) # May raise `ValidationError` Or returning a two-tuple of (value, ValidationError) : validator = typesystem . Object ( properties = typesystem . Integer ()) value , error = validator . validate_or_error ( data ) if error : ... else : ...","title":"Using fields directly"},{"location":"fields/#textual-data-types","text":"","title":"Textual data types"},{"location":"fields/#string","text":"Validates single-line text inputs. For example: username = typesystem.String(max_length=100) Arguments : allow_blank - A boolean indicating if the empty string should validate. Default: False trim_whitespace - A boolean indicating if leading/trailing whitespace should be removed on validation. Default: True max_length - A maximum number of characters that valid input stings may contain. Default: None min_length - A minimum number of characters that valid input stings may contain. Default: None pattern - A regular expression that must match. This can be either a string or a compiled regular expression. E.g. pattern=\"^[A-Za-z]+$\" Default: None format - A string used to indicate a semantic type, such as \"email\" , \"url\" , or \"color\" . Default: None","title":"String"},{"location":"fields/#text","text":"Validates multi-line strings. Takes the same arguments as String . Represented in HTML forms as a <textarea> .","title":"Text"},{"location":"fields/#boolean-data-types","text":"","title":"Boolean data types"},{"location":"fields/#boolean","text":"Represented in HTML forms as a <checkbox> . For example: is_admin = typesystem . Boolean ( default = False ) Because all fields are required unless a default is given, you'll typically want to use default=False . This is particularly true if you want to render boolean fields as HTML checkboxes, since they do not submit any input if unchecked.","title":"Boolean"},{"location":"fields/#numeric-data-types","text":"","title":"Numeric data types"},{"location":"fields/#number","text":"The base class for Integer , Float , and Decimal . You won't typically want to use this class directly, since the subclasses provide more precise behaviour. Arguments : minimum - A number representing the minimum allowed value. Inputs must be greater than or equal to this to validate. Default: None maximum - A number representing the maximum allowed value. Inputs must be less than or equal to this to validate. Default: None exclusive_minimum - A number representing an exclusive minimum. Inputs must be greater than this to validate. Default: None exclusive_maximum - A number representing an exclusive maximum. Inputs must be less than this to validate. Default: None precision - A string representing the decimal precision to truncate input with. E.g. precision=\"0.001\" . Default: None multiple_of - A number giving a value that inputs must be a strict multiple of in order to validate. E.g. multiple_of=2 will only validate even integers. Default: None","title":"Number"},{"location":"fields/#integer","text":"Takes the same arguments as Number . Returns instances of int .","title":"Integer"},{"location":"fields/#float","text":"Takes the same arguments as Number . Returns instances of float .","title":"Float"},{"location":"fields/#decimal","text":"Takes the same arguments as Number . Returns instances of decimal.Decimal .","title":"Decimal"},{"location":"fields/#enumeration-data-types","text":"","title":"Enumeration data types"},{"location":"fields/#choice","text":"Provides a fixed set of options to select from. Represented in HTML forms as a <select> . Arguments : choices - A list of two-tuples of (choice, description) . Default: None","title":"Choice"},{"location":"fields/#date-and-time-data-types","text":"","title":"Date and time data types"},{"location":"fields/#datetime","text":"Validates ISO 8601 formatted datetimes. For example \"2020-02-29T12:34:56Z\" . Returns datetime.datetime instances.","title":"DateTime"},{"location":"fields/#date","text":"Validates ISO 8601 formatted dates. For example \"2020-02-29\" . Returns datetime.date instances.","title":"Date"},{"location":"fields/#time","text":"Validates ISO 8601 formatted times. For example \"12:34:56\" . Returns datetime.time instances.","title":"Time"},{"location":"fields/#composite-data-types","text":"","title":"Composite data types"},{"location":"fields/#array","text":"Used to validate a list of data. For example: # Validates data like `[8, 7, 0, 8, 4, 5]` ratings = typesystem . Array ( items = typesystem . Integer ( min_value = 0 , max_value = 10 )) Arguments : items - Either a Field , used to validate each item in the list. Or a list of Field instances, used to validate each item in the list, positionally. Default: None additional_items - Only valid if items is a list. Either True or False , or a Field . Used to validate each additional item in the list. Default: False min_items - An integer, indicating the minimum number of items that must be present in the list. Default: None max_items - An integer, indicating the maximum number of items that may be present in the list. Default: None exact_items - An integer, indicating the exact number of items that must be present in the list. Default: None unique_items - A boolean. Used to determine if duplicate items are allowed in the list. Default: False","title":"Array"},{"location":"fields/#object","text":"Used to validate a dictionary of data. # Validates data like `{\"address\": \"12 Steeple close\", \"delivery note\": \"Leave by porch\"}` extra_metadata = typesystem . Object ( properties = typesystem . String ( max_length = 100 )) Schema classes implement their validation behaviour by generating an Object field, and automatically determining the properties and required attributes. You'll typically want to use typesystem.Reference(to=SomeSchema) rather than using the Object field directly, but it can be useful if you have a more complex data structure that you need to validate. Arguments : properties - Either a Field , used to validate each value in the object. Or a dictionary of Field instances, used to validate each item in the list, by field name. Default: None pattern_properties - A dictionary mapping regex-style strings to field instances. Used to validate any items not in properties that have a key matching the regex. Default: None additional_properties - Either a boolean, used to indicate if additional properties are allowed, or a Field used to validate any items not in properties or pattern_properties . If None then additional properties are allowed, but are not included in the validated value. Default: None min_properties - An integer representing the minimum number of properties that must be included. max_properties - An integer representing the maximum number of properties that may be included. required - A list of strings indicating any fields that are strictly required in the input.","title":"Object"},{"location":"fields/#reference","text":"Used to reference a nested schema. For example: owner = typesystem . Reference ( to = User , allow_null = True ) Arguments : to - A schema class or field instance. Required","title":"Reference"},{"location":"forms/","text":"TypeSystem gives you form rendering support, which you can either style and customize yourself, or use together with a pre-packaged theme. Let's take a look: import typesystem forms = typesystem . Jinja2Forms ( package = \"typesystem\" ) # Use the default templates. class BookingSchema ( typesystem . Schema ): start_date = typesystem . Date ( title = \"Start date\" ) end_date = typesystem . Date ( title = \"End date\" ) room = typesystem . Choice ( title = \"Room type\" , choices = [ ( 'double' , 'Double room' ), ( 'twin' , 'Twin room' ), ( 'single' , 'Single room' ) ]) include_breakfast = typesystem . Boolean ( title = \"Include breakfast\" , default = False ) form = forms . Form ( BookingSchema ) print ( form ) That'll render an HTML form which looks something like this: The default templates included by typesystem use tables to provide a simple functional layout. Notice that only the fields in the form are rendered. The surrounding <form> , <table> , and <input type=\"submit\"> tags should be included directly in any template that renders the form. < tr > < td > < label for = \"form-bookingschema-start-date\" > Start date </ label > </ td > < td > < input type = \"date\" id = \"form-bookingschema-start-date\" name = \"start_date\" required > </ td > </ tr > < tr > < td > < label for = \"form-bookingschema-end-date\" > End date </ label > </ td > < td > < input type = \"date\" id = \"form-bookingschema-end-date\" name = \"end_date\" required > </ td > </ tr > < tr > < td > < label for = \"form-bookingschema-room\" > Room type </ label > </ td > < td > < select id = \"form-bookingschema-room\" name = \"room\" > < option ></ option > < option value = \"double\" > Double room </ option > < option value = \"twin\" > Twin room </ option > < option value = \"single\" > Single room </ option > </ select > </ td > </ tr > < tr > < td > < label for = \"form-bookingschema-include-breakfast\" > Include breakfast </ label > </ td > < td > < input type = \"checkbox\" id = \"form-bookingschema-include-breakfast\" name = \"include_breakfast\" value = \"true\" > </ td > </ tr > You can include a form inside a Jinja2 template by passing it as context, and rendering the context value. Make sure to include the surrounding tags: < form action = \"/\" method = \"POST\" > < table > {{ form }} < tr > < td ></ td > < td >< input type = \"submit\" value = \"Make booking\" /></ td > </ tr > </ table > </ form > Including values and errors We can include values in a form like so: initial_values = { 'room' : 'double' , 'include_breakfast' : True } form = forms . Form ( BookingSchema , values = initial_values ) We can also include validation errors: booking , errors = BookingSchema . validate_or_error ( data ) if errors : form = forms . Form ( BookingSchema , values = data , errors = errors ) Customizing field rendering If you'd like to override the default field rendering you can switch to using your own custom templates. Switch this line: forms = typesystem . Jinja2Forms ( package = \"typesystem\" ) To instead use a templates directories: forms = typesystem . Jinja2Forms ( directory = \"templates\" ) You'll need to provide the following templates: forms/checkbox.html forms/input.html forms/select.html forms/textarea.html Using a packaged theme You can also use a pre-packaged theme, such as Bootstrap 4: # This pypi package includes `typesystem` form templates, # and pre-packaged static files. $ pip install bootstrap4 forms = typesystem . Jinja2Forms ( package = \"bootstrap4\" ) The bootstrap4 package also provides the static CSS and JavaScript files, which you can easily serve up from Starlette's StaticFiles application: # Serve everything in the local \"statics\" directory plus everything # in the \"statics\" directory of the `bootstrap4` package. statics = StaticFiles ( directory = \"statics\" , packages = [ \"bootstrap4\" ]) That will then render HTML forms using Bootstrap:","title":"Forms"},{"location":"forms/#including-values-and-errors","text":"We can include values in a form like so: initial_values = { 'room' : 'double' , 'include_breakfast' : True } form = forms . Form ( BookingSchema , values = initial_values ) We can also include validation errors: booking , errors = BookingSchema . validate_or_error ( data ) if errors : form = forms . Form ( BookingSchema , values = data , errors = errors )","title":"Including values and errors"},{"location":"forms/#customizing-field-rendering","text":"If you'd like to override the default field rendering you can switch to using your own custom templates. Switch this line: forms = typesystem . Jinja2Forms ( package = \"typesystem\" ) To instead use a templates directories: forms = typesystem . Jinja2Forms ( directory = \"templates\" ) You'll need to provide the following templates: forms/checkbox.html forms/input.html forms/select.html forms/textarea.html","title":"Customizing field rendering"},{"location":"forms/#using-a-packaged-theme","text":"You can also use a pre-packaged theme, such as Bootstrap 4: # This pypi package includes `typesystem` form templates, # and pre-packaged static files. $ pip install bootstrap4 forms = typesystem . Jinja2Forms ( package = \"bootstrap4\" ) The bootstrap4 package also provides the static CSS and JavaScript files, which you can easily serve up from Starlette's StaticFiles application: # Serve everything in the local \"statics\" directory plus everything # in the \"statics\" directory of the `bootstrap4` package. statics = StaticFiles ( directory = \"statics\" , packages = [ \"bootstrap4\" ]) That will then render HTML forms using Bootstrap:","title":"Using a packaged theme"},{"location":"json_schema/","text":"TypeSystem can convert Schema classes or Field instances to/from JSON Schema. Note TypeSystem only supports $ref pointers that use the standard \"definitions\" namespace to store referenced schemas. All references should be of the style {\"$ref\": \"#/definitions/...\"} . Using hyperlinked references, relative references, or references to parts of the document other than \"definitions\" is not supported. Let's define a schema, and dump it out into a JSON schema document: import json import typesystem class BookingSchema ( typesystem . Schema ): start_date = typesystem . Date ( title = \"Start date\" ) end_date = typesystem . Date ( title = \"End date\" ) room = typesystem . Choice ( title = \"Room type\" , choices = [ ( \"double\" , \"Double room\" ), ( \"twin\" , \"Twin room\" ), ( \"single\" , \"Single room\" ), ], ) include_breakfast = typesystem . Boolean ( title = \"Include breakfast\" , default = False ) schema = typesystem . to_json_schema ( BookingSchema ) print ( json . dumps ( schema , indent = 4 )) That will print the following JSON schema document: { \"type\" : \"object\" , \"properties\" : { \"start_date\" : { \"type\" : \"string\" , \"minLength\" : 1 , \"format\" : \"date\" }, \"end_date\" : { \"type\" : \"string\" , \"minLength\" : 1 , \"format\" : \"date\" }, \"room\" : { \"enum\" : [ \"double\" , \"twin\" , \"single\" ] }, \"include_breakfast\" : { \"type\" : \"boolean\" , \"default\" : false } }, \"required\" : [ \"start_date\" , \"end_date\" , \"room\" ] } We can also convert in the other direction: import typesystem schema = { \"type\" : \"object\" , \"properties\" : { \"start_date\" : { \"type\" : \"string\" , \"minLength\" : 1 , \"format\" : \"date\" }, \"end_date\" : { \"type\" : \"string\" , \"minLength\" : 1 , \"format\" : \"date\" }, \"room\" : { \"enum\" : [ \"double\" , \"twin\" , \"single\" ] }, \"include_breakfast\" : { \"type\" : \"boolean\" , \"default\" : False } }, \"required\" : [ \"start_date\" , \"end_date\" , \"room\" ] } validator = typesystem . from_json_schema ( schema ) validator . validate ({ 'start_date' : '2021-01-01' , 'end_date' : '2021-01-03' }) # raises `ValidationError: {'room': 'This field is required.'}`","title":"JSON Schema"},{"location":"references/","text":"References are a special type of field used to interlink schemas. The simplest way to use a reference, is with a schema class as a the target. import typesystem class Artist ( typesystem . Schema ): name = typesystem . String ( max_length = 100 ) class Album ( typesystem . Schema ): title = typesystem . String ( max_length = 100 ) release_date = typesystem . Date () artist = typesystem . Reference ( to = Artist ) Using a schema class directly might not always be possible. If you need to to support back-references or cyclical references, you can use a string-literal reference and provide a SchemaDefinitions instance, which is a dictionary-like object providing an index of reference lookups. import typesystem definitions = typesystem . SchemaDefinitions () class Artist ( typesystem . Schema ): name = typesystem . String ( max_length = 100 ) class Person ( typesystem . Schema ): name = typesystem . String ( max_length = 100 ) release_date = typesystem . Date () artist = typesystem . Reference ( to = 'Artist' , definitions = definitions ) definitions [ 'Artist' ] = Artist definitions [ 'Person' ] = Person A shorthand for including a schema class in the definitions index, and for setting the definitions on any Reference fields, is to declare schema classes with the definitions keyword argument, like so: import typesystem definitions = typesystem . SchemaDefinitions () class Artist ( typesystem . Schema , definitions = definitions ): name = typesystem . String ( max_length = 100 ) class Person ( typesystem . Schema , definitions = definitions ): name = typesystem . String ( max_length = 100 ) release_date = typesystem . Date () artist = typesystem . Reference ( to = 'Artist' ) Registering schema classes against a SchemaDefinitions instance is particularly useful if you're using JSON schema to document the input and output types of a Web API, since you can easily dump all the type definitions: import json import typesystem definitions = typesystem . SchemaDefinitions () class Artist ( typesystem . Schema , definitions = definitions ): name = typesystem . String ( max_length = 100 ) class Person ( typesystem . Schema , definitions = definitions ): name = typesystem . String ( max_length = 100 ) release_date = typesystem . Date () artist = typesystem . Reference ( to = 'Artist' ) document = typesystem . to_json_schema ( definitions ) print ( json . dumps ( document , indent = 4 )) # { # \"definitions\": { # \"Artist\": { # \"type\": \"object\", # \"properties\": { # \"name\": { # \"type\": \"string\", # \"minLength\": 1, # \"maxLength\": 100 # } # }, # \"required\": [ # \"name\" # ] # }, # \"Person\": { # \"type\": \"object\", # \"properties\": { # \"name\": { # \"type\": \"string\", # \"minLength\": 1, # \"maxLength\": 100 # }, # \"release_date\": { # \"type\": \"string\", # \"minLength\": 1, # \"format\": \"date\" # }, # \"artist\": { # \"$ref\": \"#/definitions/Artist\" # } # }, # \"required\": [ # \"name\", # \"release_date\", # \"artist\" # ] # } # } # }","title":"References"},{"location":"schemas/","text":"Let's start by defining some schema classes. import typesystem class Artist ( typesystem . Schema ): name = typesystem . String ( max_length = 100 ) class Album ( typesystem . Schema ): title = typesystem . String ( max_length = 100 ) release_date = typesystem . Date () artist = typesystem . Reference ( Artist ) We've got some incoming user data that we'd like to validate against our schema. data = { 'title' : 'Double Negative' , 'release_date' : '2018-09-14' , 'artist' : { 'name' : 'Low' } } We can validate the data against a Schema by using .validate(data) . album = Album . validate ( data ) If validation succeeds, this will return an Album instance. If validation fails, a ValidationError will be raised. Alternatively we can use .validate_or_error(data) , which will return a two-tuple of (value, error) . Either one of value or error will be None . album , error = Album . validate_or_error ( data ) if error : ... else : ... Working with validation errors The ValidationError class presents a dict-like interface: invalid_data = { 'title' : 'Double Negative' , 'release_date' : '2018.09.14' , 'artist' : { 'name' : 'x' * 1000 } } album , error = Album . validate_or_error ( invalid_data ) print ( dict ( error )) # {'release_date': 'Must be a valid date format.', 'artist': {'name': 'Must have no more than 100 characters.'}} print ( list ( error . keys ())) # ['release_date', 'artist'] If you want more precise information about exactly what error messages exist, you can access each individual message with error.messages() : album , error = Album . validate_or_error ( invalid_data ) for message in error . messages (): print ( f '{message.index!r}, {message.code!r}, {message.text!r})' ) # ['release_date'], 'format', 'Must be a valid date format.' # ['artist', 'name'], 'max_length', 'Must have no more than 100 characters.' Working with schema instances Schema instances are returned by calls to .validate() . data = { 'title' : 'Double Negative' , 'release_date' : '2018-09-14' , 'artist' : { 'name' : 'Low' } } album = Album . validate ( data ) print ( album ) # Album(title='Double Negative', release_date=datetime.date(2018, 9, 14), artist=Artist(name='Low')) Attributes on schemas return native python data types. print ( type ( album . release_date )) # <class 'datetime.date'> Schema instances present a dict-like interface, allowing them to be easily serialized. print ( dict ( album )) # {'title': 'Double Negative', 'release_date': '2018-09-14', 'artist': {'name': 'Low'}} Index lookup on schema instances returns serialized datatypes. print ( type ( album [ 'release_date' ])) # <class 'str'> You can also instantiate schema instances directly. artist = Artist ( name = 'Low' ) album = Album ( title = 'Double Negative' , release_date = '2018-09-14' , artist = artist ) When instantiating with keyword arguments, each keyword argument will be validated. If instantiated directly, schema instances may be sparsely populated. Any unused attributes without a default will not be set on the instance. artist = Artist ( name = 'Low' ) album = Album ( title = 'Double Negative' , artist = artist ) print ( album ) # Album(title='Double Negative', artist=Artist(name='Low')) [sparse] album . release_date # AttributeError: 'Album' object has no attribute 'release_date' print ( dict ( album )) { 'title' : 'Double Negative' , 'artist' : { 'name' : 'Low' }} Sparsely populated instances can be useful for cases of loading data from database, when you do not need to retrieve all the fields, or for cases of loading nested data where no database join has been made, and only the primary key of the relationship is known. You can also instantiate a schema from an object instance or dictionary. new_album = Album ( album ) Note that data validation is not applied when instantiating a schema instance directly from an instance or dictionary. This should be used when creating instances against a data source that is already known to be validated, such as when loading existing instances from a database.","title":"Schemas"},{"location":"schemas/#working-with-validation-errors","text":"The ValidationError class presents a dict-like interface: invalid_data = { 'title' : 'Double Negative' , 'release_date' : '2018.09.14' , 'artist' : { 'name' : 'x' * 1000 } } album , error = Album . validate_or_error ( invalid_data ) print ( dict ( error )) # {'release_date': 'Must be a valid date format.', 'artist': {'name': 'Must have no more than 100 characters.'}} print ( list ( error . keys ())) # ['release_date', 'artist'] If you want more precise information about exactly what error messages exist, you can access each individual message with error.messages() : album , error = Album . validate_or_error ( invalid_data ) for message in error . messages (): print ( f '{message.index!r}, {message.code!r}, {message.text!r})' ) # ['release_date'], 'format', 'Must be a valid date format.' # ['artist', 'name'], 'max_length', 'Must have no more than 100 characters.'","title":"Working with validation errors"},{"location":"schemas/#working-with-schema-instances","text":"Schema instances are returned by calls to .validate() . data = { 'title' : 'Double Negative' , 'release_date' : '2018-09-14' , 'artist' : { 'name' : 'Low' } } album = Album . validate ( data ) print ( album ) # Album(title='Double Negative', release_date=datetime.date(2018, 9, 14), artist=Artist(name='Low')) Attributes on schemas return native python data types. print ( type ( album . release_date )) # <class 'datetime.date'> Schema instances present a dict-like interface, allowing them to be easily serialized. print ( dict ( album )) # {'title': 'Double Negative', 'release_date': '2018-09-14', 'artist': {'name': 'Low'}} Index lookup on schema instances returns serialized datatypes. print ( type ( album [ 'release_date' ])) # <class 'str'> You can also instantiate schema instances directly. artist = Artist ( name = 'Low' ) album = Album ( title = 'Double Negative' , release_date = '2018-09-14' , artist = artist ) When instantiating with keyword arguments, each keyword argument will be validated. If instantiated directly, schema instances may be sparsely populated. Any unused attributes without a default will not be set on the instance. artist = Artist ( name = 'Low' ) album = Album ( title = 'Double Negative' , artist = artist ) print ( album ) # Album(title='Double Negative', artist=Artist(name='Low')) [sparse] album . release_date # AttributeError: 'Album' object has no attribute 'release_date' print ( dict ( album )) { 'title' : 'Double Negative' , 'artist' : { 'name' : 'Low' }} Sparsely populated instances can be useful for cases of loading data from database, when you do not need to retrieve all the fields, or for cases of loading nested data where no database join has been made, and only the primary key of the relationship is known. You can also instantiate a schema from an object instance or dictionary. new_album = Album ( album ) Note that data validation is not applied when instantiating a schema instance directly from an instance or dictionary. This should be used when creating instances against a data source that is already known to be validated, such as when loading existing instances from a database.","title":"Working with schema instances"},{"location":"tokenized_errors/","text":"For JSON and YAML content, TypeSystem can provide error messages with position indicators showing exactly where the error occurred in the raw textual content. import typesystem class Config ( typesystem . Schema ): num_worker_processes = typesystem . Integer () enable_auto_reload = typesystem . Boolean () text = '''{ \"num_worker_processes\": \"x\", \"enable_auto_reload\": \"true\" }''' value , messages = typesystem . validate_json ( text , validator = Config ) assert value is None for message in messages : line_no = message . start_position . line_no column_no = message . start_position . column_no print ( f \"Error {message.text!r} at line {line_no}, column {column_no}.\" ) # Error 'Must be a number.' at line 2, column 29. The two functions for parsing content and providing positional error messages are: validate_json(text_or_bytes, validator) validate_yaml(text_or_bytes, validator) In both cases validator may either be a Schema class, or a Field instance. Both functions return a two-tuple of (value, messages) . If the messages list is non-empty, then value will be None .","title":"Tokenized Errors"}]}